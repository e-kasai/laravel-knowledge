
---

いいじゃない、その要件ならWebhookなしでいけるわ。
「Checkout→テストカード入力→success_urlで戻る→サーバで検証→DB確定→フラッシュ表示」よ。

全体像

Checkout作成時に order/item を特定できる情報 を埋め込む（metadata / client_reference_id）
戻り先（success_url）で Stripeに問い合わせ。paid ＆ succeeded を確認。
OKなら DBを確定更新（トランザクション）。その後 購入ページへredirect+flash。
失敗/未完了は「手続き中」メッセージだけ返す。

---

1) Checkout セッション作成（サーバ側）

支払い1件を識別するため、PaymentIntentのmetadataに order_id / item_id / user_id を入れる。

戻り先に {CHECKOUT_SESSION_ID} を付ける。

```php
// CheckoutController@create（一例）
$session = \Stripe\Checkout\Session::create([
  'mode' => 'payment',
  'line_items' => [[
    'price_data' => [
      'currency' => 'jpy',
      'unit_amount' => $item->price, // 税込額（最小単位）
      'product_data' => ['name' => $item->item_name],
    ],
    'quantity' => 1,
  ]],
  'success_url' => route('purchase.complete', [], true).'?session_id={CHECKOUT_SESSION_ID}',
  'cancel_url'  => route('purchase.item', [], true),
  'client_reference_id' => (string)$order->id, // どちらでも可
  'payment_intent_data' => [
    'metadata' => [
      'order_id' => $order->id,
      'item_id'  => $item->id,
      'user_id'  => auth()->id(),
    ],
  ],
]);
```

テストカード：4242 4242 4242 4242（任意の将来日、有効CVC）で即成功。

2) ルート
```php
// success_urlの受け口
Route::get('/purchase/complete', [CheckoutController::class, 'complete'])
    ->name('purchase.complete')
    ->middleware('auth');
```

3) success_url で検証→確定→リダイレクト

session_id を受け取る。

Stripe APIで Session を expand: payment_intent 付きで取得。

判定：$session->payment_status === 'paid' かつ $session->payment_intent->status === 'succeeded'。

OKなら DB確定更新 → redirect()->route('purchase.item')->with('message','購入が完了しました');

未完了なら ** with('message','お支払い手続き中です'); **

```php
public function complete(Request $request)
{
    $sid = $request->query('session_id');
    abort_unless($sid, 400);

    \Stripe\Stripe::setApiKey(config('services.stripe.secret'));
    $session = \Stripe\Checkout\Session::retrieve([
        'id' => $sid,
        'expand' => ['payment_intent'],
    ]);

    $isPaid = $session->payment_status === 'paid'
           && ($session->payment_intent->status ?? null) === 'succeeded';

    if ($isPaid) {
        // ここで確定処理（最小でも2点）
        \DB::transaction(function () use ($session) {
            $pi = $session->payment_intent;
            $orderId = $pi->metadata->order_id ?? $session->client_reference_id;

            $order = Order::lockForUpdate()->findOrFail($orderId);
            if (!$order->is_paid) {
                $order->update([
                    'is_paid' => true,
                    'paid_at' => now(),
                    'payment_method' => 'card',    // or 'stripe'
                    'provider_txn_id' => $pi->id,  // PaymentIntent ID
                ]);

                Item::whereKey($order->item_id)->update(['is_sold' => true]);
            }
        });

        return redirect()->route('purchase.item')
            ->with('message', '購入が完了しました');
    }

    return redirect()->route('purchase.item')
        ->with('message', 'お支払い手続き中です');
}
```

4) Blade（フラッシュ表示）
@if (session('message'))
  <div class="alert">{{ session('message') }}</div>
@endif

要点（ビジネス視点）

Webhookなし運用でも、クレカの即時決済はこのフローで十分。「購入できる」を満たす。
整合性の鍵は「戻り先でStripeに都度問い合わせて、有料確定をサーバ側で判定する」こと。
DB確定はトランザクション＋行ロックを推奨（多重クリック対策）。
order_id を metadata / client_reference_id の どちらか一方に統一すると保守が楽。

---

動作確認チェックリスト

テスト鍵で起動
商品→購入→支払い方法「カード」→Checkoutで 4242… を入力→支払い。
success_url で戻る→「購入が完了しました」表示。
DB：orders.is_paid = 1 / paid_at セット / provider_txn_id 記録。items.is_sold = 1。

これで「Stripeに遷移→テストカード決済→戻ってフラッシュ→DB保存」まで、最短・シンプルに仕上がるわ。
次は Order の最低カラム（amount/payment_method/provider_txn_id）を確認して、足りなければ足すだけよ。