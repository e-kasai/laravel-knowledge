
---

#### 目的: テスト実行時だけ、DBや環境の設定を切り替える

- Laravelのテストランナー（PHPUnit経由）は、通常の .env ではなく .env.testing を優先して読む
- でもここで指定することで確実にテスト用DBを使うという保険になる
- `.env / .env.testing`で `DB_CONNECTION=mysql_test` とか書く → 「どの接続を使うか」指定してる

#### 手順

1. .env.testing作成
```bash
//phpコンテナ内で実行
cp .env .env.testing
```

2. ファイルの作成ができたたら、.env.testingファイルの文頭部分にある
`APP_ENV`と`APP_KEY`を編集

```php
// .env.testing

APP_NAME=Laravel

- APP_ENV=local      //delete
- APP_KEY=base64:vPtYQu63T1fmcyeBgEPd0fJ+jvmnzjYMaUf7d5iuB+c=     //delete
  
+ APP_ENV=testing  //testingと指定
+ APP_KEY=     //test用のkeyを作成するために一度からにする
  
APP_DEBUG=true
APP_URL=http://localhost
```

---

3. .env.testingにデータベースの接続情報を追加
```php
  DB_CONNECTION=mysql_test   //テスト用接続先に
  DB_HOST=mysql
  DB_PORT=3306
  
- DB_DATABASE=laravel_db     //delete
- DB_USERNAME=laravel_user   //delete
- DB_PASSWORD=laravel_pass   //delete
  
+ DB_DATABASE=demo_test      //add
+ DB_USERNAME=root           //add
+ DB_PASSWORD=root          //add
```

---

4. .env.testing.exampleを作成する(APPキー作成より前に)
** APPKEYは空欄にする **
ex
```php
APP_NAME=Laravel
APP_ENV=testing
APP_KEY=
APP_DEBUG=true
APP_URL=http://localhost

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql_test
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=app_test
DB_USERNAME=root
DB_PASSWORD=root

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DRIVER=local
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=127.0.0.1

REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="test@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_APP_CLUSTER=mt1

MIX_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
MIX_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

STRIPE_KEY=pk_test_dummy
STRIPE_SECRET=sk_test_dummy
```

5. テスト用のアプリケーションキーを 作成
```bash
//phpコンテナ内
 php artisan key:generate --env=testing
 php artisan config:clear //キャッシュを削除して確実に反映させる
```

---
#### .env.testingないとどうなる

 - phpunitに↓これだけの内容が記載されてたらそれでよくない？
```php
<php>
        <server name="APP_ENV" value="testing"/>             //ENVの指定もある
        <server name="BCRYPT_ROUNDS" value="4"/>
        <server name="CACHE_DRIVER" value="array"/>

        <server name="DB_CONNECTION" value="mysql_test"/>   //DB接続先ある
        <server name="DB_DATABASE" value="app_test"/>       //DB名の指定もある
        <server name="MAIL_MAILER" value="array"/>
        <server name="QUEUE_CONNECTION" value="sync"/>
        <server name="SESSION_DRIVER" value="array"/>
        <server name="TELESCOPE_ENABLED" value="false"/>
    </php>
```


** 結論：.env.testingはあったほうがいい **

理由
- phpunitだけだとカバーしきれない
- チーム開発で明示性が落ちる

例：

phpunit.xml の <server> がある場合

```html
<server name="APP_ENV" value="testing"/>
<server name="DB_CONNECTION" value="mysql"/>
<server name="DB_DATABASE" value="laravel_test"/>
```

- APP_ENV → 強制的に testing
- DB_CONNECTION → mysql に上書き
- DB_DATABASE → laravel_test に上書き

でも、、、
** それ以外（DB_USERNAME, DB_PASSWORD, MAIL_DRIVER, など）は .env のまま **
書かれていないもの（DBユーザーやメール設定など）は .env の値がそのまま残ってしまう

---

#### 起こりうる事態

① 本番/開発用の値を間違って使用してメールが飛ぶ

例：.env に以下が書いてある場合

```php
MAIL_MAILER=smtp
MAIL_HOST=smtp.gmail.com
```

→ テスト実行時にも本物のSMTPサーバーに繋ごうとする。
結果、テストが失敗するか、最悪メールが飛んでしまう。

---
② 本番/開発DBを誤って破壊

phpunit.xml で DB_DATABASE=laravel_test を上書きしても、

もし DB_USERNAME や DB_PASSWORD を書いていなかったら .env の開発用ユーザーで接続される。

設定次第では 誤って本番/開発DBをマイグレーション＆消去してしまう。

---

③ 環境が混ざってチーム開発で混乱

人によっては phpunit.xml を見落として .env.testing が無いことに気づかない。
CI/CD でも「どの環境変数が使われるのか」が分かりにくくなる。

---

④ CI 環境とローカルで動きがズレる

CI では .env.testing を想定していることが多い。
ローカルで「phpunit.xmlだけで部分上書き」していると挙動が違う。

結果、ローカルで緑（成功）でも CI では赤（失敗）になる現象が起きる。

---

#### 補足：CI

CI = Continuous Integration（継続的インテグレーション）
日本語では「コードを継続的に統合してテストする仕組み」。

具体的なイメージ

GitHub にコードを push するとGitHub Actions や CircleCI などのサービスが自動でテストを実行
→ 人間がローカルで php artisan test を叩かなくていい


** メリット **

ローカルで緑でもCIで赤
→ 「人によって環境が違う」問題を早期発見できる

提出前に自動でテストが走る
→ 「壊れたコード」を混ぜにくい

大規模開発や本番環境では 必須の安全装置

---