---
# バインド # singleton
---

---

#### 例：メール認証まだのユーザーがログインしようとしたらメール認証ページへリダイレクト

** point **
Laravel Fortify のログイン後の遷移先はデフォルトでは変更できない。

** どうするか？ **
* Fortify標準のままでは「ログイン後の挙動」を細かく制御できない
* だから自分でファイル（Responseクラス）を用意して
* ServiceProviderで アタッチ（バインド） して上書きする

---

### step1 Responseクラスを新規作成

`app/Http/Responses/LoginResponse.php`
* Responseディレクトリを作りLoginResponseファイルを作成

```php
namespace App\Http\Responses;

use Laravel\Fortify\Contracts\LoginResponse as LoginResponseContract;

class LoginResponse implements LoginResponseContract
{
    public function toResponse($request)
    {
        $user = $request->user();

        if ($user && ! $user->hasVerifiedEmail()) {
            return redirect()->route('verification.notice'); // 未認証はここへ
        }

        return redirect()->intended(route('items.index')); // 認証済みは一覧へ
    }
}
```

---

### step2 FortifyServiceProviderでバインド

```php
use Laravel\Fortify\Contracts\LoginResponse as LoginResponseContract;
use App\Http\Responses\LoginResponse;

public function register(): void
{
    $this->app->singleton(LoginResponseContract::class, LoginResponse::class);
}
```

---
#### 挙動
* ゲスト：一覧は見られる　（一覧ページにはmiddleware auth つけてないから）
* メール未認証ログイン：メール認証ページへ強制リダイレクト
* メール認証済みログイン：商品一覧へ

---

#### なぜこうしないとだめか

Laravel Fortify は「契約（Contract, インターフェース）」だけを用意していて、デフォルト実装は vendor/laravel/fortify/... の中にある
でも vendor の中は触っちゃダメ（アップデートで消えるから）

だからこうする：
自分のアプリ側 (app/Http/Responses/) に 同じ契約を実装したクラス を作る

FortifyServiceProvider で
$this->app->singleton(LoginResponseContract::class, LoginResponse::class);

と書いて、「契約(LoginResponseContract)を解決するときは私のLoginResponseを使って！」 と教える

すると Fortify はデフォルトじゃなく、自分のクラスを呼んでくれる