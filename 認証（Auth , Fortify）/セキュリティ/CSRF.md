
# CSRFとは
cross site request forgery (サイトをまたいだforgery ＝ 偽造・なりすまし）

# 具体例
ユーザーが Amazon にログインした状態のまま、別の悪意あるページを開くことで、
Amazon に対して本人になりすましたリクエストが送られる


# なぜできるか
- セッションはブラウザを閉じる（ブラウザのウィンドウを全部閉じる）かログアウトしないと消えない
- セッションはタブ単位でもウィンドウ単位でもなく”ブラウザ単位”で保存される
- だからログイン時情報をブラウザが持っている状態で悪意のあるページにアクセスするとそれら（セッションIDを保持した Cookie）が利用される


# 対策
formタグの下に@csrf

# @csrfの挙動

1. 正規ページを開く
```blade
<form method="POST">
  @csrf
```

2. サーバー：ランダムなトークンを作って、セッションに保存　＆　HTMLの hidden input に埋め込む
```blade
<input type="hidden" name="_token" value="abc123...">
```

3. ブラウザはその HTML を受け取る = このトークンは HTMLの中にしか存在しない

- 正規ページで発行された CSRF トークンを持たないリクエストをはじく
- ブラウザから送られてきたトークン = サーバーがセッションに保存しているトークンでなければはじく


# tokenは盗めない理由
結論（まず一言）

ブラウザには「別のサイトの中身を勝手に読んではいけない」という厳しいルールがあるからです。

このルールを
同一オリジンポリシー（Same-Origin Policy）
と言います。

そもそも「オリジン」とは

オリジン = 次の3つの組み合わせです。

スキーム（http / https）
ドメイン（example.com）
ポート（:80 など）

この3つが 全部同じ ＝ 同一オリジン
1つでも違う ＝ 別オリジン

具体例で見る
正規サイト
https://yahoo.co.jp

攻撃者ページ
https://evil.example.com


👉 ドメインが違う
👉 別オリジン

ブラウザの鉄の掟（重要）

別オリジンのページに対しては：

❌ HTMLの中身を読む

❌ hidden input を覗く

❌ JavaScript変数にアクセスする

❌ DOMを操作する

全部禁止です。

じゃあ何はできるの？

実はこれだけは許されています。

⭕ リクエストを送る（form / img / script など）

理由：

Web が成り立たなくなるから
（画像・広告・外部サービスが使えない）

👉
送るだけはOK、読むのはNG

CSRFが成立する理由と防げる理由
なぜ成立する？

攻撃者ページ → Yahoo に 送るのはOK

Cookie はブラウザが自動で付ける

なぜトークンは盗めない？

Yahoo の HTML を 読むのは禁止

hidden input の中身も読めない

👉
「送信はできるが、情報は盗めない」

この非対称性がポイントです。



# 開発者ツールでみれるのでは？

開発者ツールで見えている HTML は？

👉 今表示しているページ自身の HTML だけです。

Yahoo を開いているタブ
→ Yahoo の HTML は見える

攻撃者ページを開いているタブ
→ 攻撃者ページの HTML しか見えない

別タブ・別サイトの HTML は見えません。

ここが勘違いポイント

開発者ツールでHTML見れるよ？

✔️ あなた（人間）は見える
❌ 攻撃者ページの JavaScript は見えない

CSRFの話で重要なのは
**「JavaScriptが読めるかどうか」**です。

なぜ JS からは読めない？

たとえば攻撃者ページの JS で、こんなことをしようとしても：

// YahooのHTMLを読みたい（できない）
fetch("https://yahoo.co.jp/profile")
  .then(res => res.text())
  .then(html => console.log(html));


👉 ブラウザが強制的にブロックします。

理由：

別オリジン（ドメイン違い）

Same-Origin Policy に違反