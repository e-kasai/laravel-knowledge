
---

#### 結論

- Laravelの自動モデルバインディングは 「ルートのパラメータ名」=「モデルのクラス名の単数形」 が前提
- ルートのプレースホルダ {xxx} と　モデルのクラス名 Xxx
- この2つが一致すると、Laravelが自動で `Xxx::findOrFail($id)` をやってくれる 
---

### 解説

#### 単数形 = OK

```php
Route::get('/items/{item}', [ItemController::class, 'show']);`
```
- `{item}` というパラメータ名
- モデル名も`Item`
- コントローラの引数が `Item $item`

 ---
 
#### 条件がそろったときの laravel の考え

- ルートパラメータ `{item} `を見て「`item`って書いてあるな」と思う
- コントローラの引数 `Item $item` を見て「`Item`クラスだな」と思う
- `Item` クラスは `App\Models\Item` だから、そのテーブル `items` を探そうと思う
- URLの `{item}` に入ってきた値（例: 5）を `Item::findOrFail(5) `して $item に代入

---
#### ポイント

- 「クラス名」というのは App\Models\Item の 末尾の名前（Item） を指している (Eloquentモデルのクラス名)
- ルートの prefix はこれと一致している必要がある
- だから {items} とか複数形で書いちゃうと、クラス名 が単数形で合わなくて自動解決されない

---

#### 例外措置

- どうしても複数形を使うなら Route::model() で明示指定しないとだめ
- 主キーを id 以外にしたい場合はモデルで `getRouteKeyName()` をオーバーライドしないとだめ