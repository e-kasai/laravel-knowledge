
---

### 基本
* ルート定義で {item} のようなプレースホルダを使うと、Laravelが自動でモデルを探してくれる
* コントローラで型指定すると、対応するモデルのインスタンスがそのまま注入される

- web.phpで `/items/{item}` みたいに書いてあると、Laravelが自動で `{item}` の値（例えば 5）を探して 
`Item::findOrFail(5)` をしてくれる。
- そしてその結果（Item モデルのインスタンス）をコントローラーの引数 $item に渡してくれる。

#### 仕組み

たとえばルートがこう定義されているとする：

```php
Route::post('/purchase/{item}', [PurchaseController::class, 'store'])
    ->name('purchase.item');
```

ここで {item} は URLのパラメータ。
本来なら `route('purchase.item', ['item' => 5])` って書かないと `/purchase/5` みたいなURLにならない。

---
でも $item モデルを渡すと？

- LaravelはEloquentモデルに `getRouteKey()` っていうメソッドを用意してる。
- デフォルトだと id を返すようになってる。

```
//こういうの
public function getRouteKey()
{
    return $this->getAttribute($this->getRouteKeyName()); 
    // つまり通常は $this->id
}
```

だから route('purchase.item', $item) と書くと：

- Laravelが $item を見て、
- getRouteKey() を呼び出して、
- $item->id を取り出して、

`/purchase/5` みたいにURLを組み立ててくれる。

---
### まとめると

- idは $item モデルの getRouteKey() メソッドから来てる
- getRouteKey() はデフォルトでは id カラムが使われる
- もしモデルで getRouteKeyName() をオーバーライドしたら別のカラム（例: slug）になる

---

#### モデルバインディングすると何が便利なのか

- この `$item` は`Itemモデルのインスタンス`って型指定済みになる　＝　わざわざ `Item::findOrFail($id)`を書かないで済む


---
#### 例

```php
// routes/web.php
Route::get('/item/{item}', [DetailController::class, 'show'])
    ->name('details.show');

// Controller
public function show(Item $item)
{
    // URL /item/5 → Item::findOrFail(5) の結果が $item に入る
}

```


#### 解説

1. ルートで `/item/{item}` と書く
2. URL `/item/5` にアクセスすると、{item} が 5 に置き換わる
3. コントローラの引数に `Item $item` と型指定があるので、Laravelは`Item::findOrFail(5)` を実行

その結果の Itemモデルのインスタンス が `$item` に渡される
* イメージ *
```php
Item {#1234
  id: 5,
  item_name: "Laravel本",
  price: 2000,
  condition: 1,
  created_at: "2025-09-01 10:00:00",
  updated_at: "2025-09-01 10:00:00",
}
```

補足:
`{item}`（ルートプレースホルダ） → URLの数字を受け取る
`Item $item`（コントローラ引数） → モデルに変換して注入される


---

####  BladeでのURL生成

1. モデルオブジェクトまるごと渡すやり方
```html
//モデルバインディングの場合
<a href="{{ route("details.show",$item) }}">変更する</a>

//モデルバインディングじゃない場合(キー名{item}なので item->id で id をいちいち取得する必要がある)
<a href="{{ route("details.show",['item'=>$item->id]) }}">変更する</a>
```

**  コードがスッキリするし、getRouteKey() をカスタマイズすれば id 以外のキー（例: slug）も使える **

---
2. 配列で渡すやり方

```html
<a href="{{ route('details.show',  ['item' => $item->id]) }}">
```

`'item' => $item->id`
この 'item' は ルート定義の {item} に対応している。
つまり　「この `{item}` に `$item->id` を入れてね」って指定してる。

* ルート定義の {item} に、数字（id）をそのまま渡してる
* 中身はただの 数値

** 明示的に「このidを入れる」と指定したいときに使う **

---

実際の生成URL

* どちらも結果的に `/item/5/favorite` になる

** ルート名での違いの例: **
* ルートが /item/{item} → /item/5
* ルートが /detail/{item} → /detail/5