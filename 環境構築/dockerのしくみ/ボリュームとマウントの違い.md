
---

## ボリューム

- コンテナの外（＝ホスト）にデータを保存する仕組み
- ボリューム名で分かれるので同じ名前だと共有されてしまう
- プロジェクトごとに分けたいときはボリューム名にプロジェクト名を含める
- Dockerが内部に「ボリューム名」という専用領域を作る（手動では触らない）
- ホストのどこにあるか分かりにくい


```yml
# docker-compose.yml
services:
  mysql:
    image: mysql:8
    volumes:
      - movie_app_db_data:/var/lib/mysql     # movie_app_db_data ボリュームをコンテナ内の /var/lib/mysql にマウントする

volumes:
  movie_app_db_data:   # プロジェクト名を含めたボリューム名の例
```

### 保存場所

| 視点 | フォルダ | 意味 |
|------|-----------|------|
| ホスト側 | /var/lib/docker/volumes/ボリューム名/_data | この中に実際のMySQLデータファイルが入っている = 物理的な保存場所|
| コンテナ側 | /var/lib/mysql | MySQLがアクセスしている場所（ボリュームがマウントされてる） |

### コンテナ削除してもボリュームが残る理由
- Dockerの「コンテナ」と「ボリューム」が別物として管理されているから


---

## マウント

- マウント（bind mount）は、ホスト上の実フォルダと中身を共有
- Finderやエクスプローラで中身を直接見れる
- Git管理にも入れられる（.gitignoreで除外するのが普通）
- VSCodeで編集したファイルが即コンテナ内でも反映される
- パソコンの src フォルダを、コンテナの /var/www/ に「窓を開けてつないでる」イメージ

### 例

```yml
volumes:
  - ./src:/var/www/
  - ./docker/mysql/data:/var/lib/mysql
```

### mysql/dataフォルダ内を見る方法

エクスプローラで直接開けない理由
1. docker/mysql/data は、Dockerコンテナ（MySQL）が動作中に「排他アクセス（ロック）」しているのでwindowsからは見れない
2. MySQLがファイルを作るとき、rootユーザー権限（Linux内）でこれらを作るためWSL側からみると権限がない

```bash
# 方法１：WSLのターミナルから直接見る
cd ~/project_files/flea_market/docker/mysql/data
ls -a
```

```bash
# 方法２：コンテナから入る
docker compose exec mysql bash
cd /var/lib/mysql
ls -a
```

---

## Bind Mount（マウント） vs Volume（ボリューム）の比較

| 項目 | Bind Mount（例：./src:/var/www） | Volume（例：db_data:/var/lib/mysql） |
|------|----------------------------------|--------------------------------------|
| 保存場所 | プロジェクトのフォルダ内（ホストが指定） | /var/lib/docker/volumes/...（Dockerが自動管理） |
| 中身を直接見られる | 見える（Explorer/FinderでOK） | 見えない（CLIで探す必要あり） |
| コンテナ削除 (docker rm) | ✅ データ残る | ✅ データ残る |
| docker-compose down | ✅ データ残る | ✅ データ残る |
| docker-compose down -v | ⚠️ 手動で削除しない限り残る | ❌ 消える（ボリュームも削除） |
| バックアップのしやすさ | フォルダごとコピーできる | docker run --rm -v コマンド等が必要 |
| 本番向き？ | △（データ消えやすい・安全でない）[^1] | ✅（独立していて安全） |
| 開発向き？ | ✅ VSCodeでコード変更→ブラウザでF5で即反映可能 | ❌いちいち再ビルドが必要|


---

## 結論まとめ

| 状況 | 向いてる方式 |
|------|---------------|
| 開発中：コード編集や動作確認 | 🔹 Bind Mount（ホストと同期） |
| 本番環境：データを安全に保持 | 🔹 Volume（Dockerが管理） |

---

## 実際の運用

開発用と本番用で、docker-compose.yml を2つ用意し実行コマンドも分ける

イメージ図
```
project-root/
├─ docker-compose.yml          ← 開発用（Bind Mount）  # ./src:/var/www のようにマウント。編集が即反映される。
├─ docker-compose.prod.yml     ← 本番用（Volume）      # ボリューム化
├─ docker/
│   ├─ php/
│   ├─ mysql/
│   └─ nginx/
└─ src/
```

実行コマンド
```bash
# 開発中（通常どおり）
docker compose up -d

# 本番デプロイ時
docker compose -f docker-compose.prod.yml up -d
# -f オプションで使う設定ファイルを指定できる
```

[^1]: ## 🧩 Bind Mount と Volume のリスク比較
	
	| リスク例 | Bind Mountで起こること | Volumeならどうなる？ |
	|-----------|--------------------------|------------------------|
	| フォルダ削除 | `./docker/mysql/data` を手動で消すと、DBも完全に消える | Docker内部の倉庫なので安全 |
	| プロジェクト移動／リネーム | `project_files/flea_market` → `flea_market2` にするとリンク切れ | VolumeはDocker内部名で管理されるので影響なし |
	| 他のPCにコピー | `data` フォルダが空だと初期化される（空フォルダで上書き） | Volumeはコンテナ再構築でも中身が残る |
	| 誤操作（rm -rf など） | ローカルの消し忘れでDBまで消える | Volumeは隔離領域なので被害なし |
